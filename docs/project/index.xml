<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | Nazanin Minaian</title>
    <link>https://nminaian.github.io/Website/project/</link>
      <atom:link href="https://nminaian.github.io/Website/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 25 Nov 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://nminaian.github.io/Website/images/icon_hu835ad7ad16c4928b4b63a348fd887239_17370_512x512_fill_lanczos_center_2.png</url>
      <title>Projects</title>
      <link>https://nminaian.github.io/Website/project/</link>
    </image>
    
    <item>
      <title>Computer Vision-based Fluid-Structure Interaction Tracking Software</title>
      <link>https://nminaian.github.io/Website/project/imageprocessing/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://nminaian.github.io/Website/project/imageprocessing/</guid>
      <description>&lt;h2 id=&#34;project-scope&#34;&gt;Project Scope&lt;/h2&gt;
&lt;p&gt;Ionic polymer-metal composites (IPMCs) are a type of electroactive polymer typically used in soft-robotic applications. The unique two-way transduction property of IPMCs allows for both actuation and sensing, which, in conjunction with its ability to be used in aqueous environments, can be used for various underwater applications. For this study, we aim to use the IPMC&#39; s unique sensing capabilities as an underwater flow sensor, capable of measuring the flow field of the surrounding environment. This approach is dependent on signal characterization of the acquired voltage response and the fluid dynamics phenomenon of K√°rm√°n vortex streets. The latter requires the sensor to detect the frequency of vortex shedding from either the sensor itself or from an obstructing object positioned before the IPMC sensor. The project was split into three major goals:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Capture and track the relative velocity of IPMC sensor using imaging and image process techniques.Confirm this value with our known value, and calculate expected vortex shedding frequency with this velocity.&lt;/li&gt;
&lt;li&gt;Capture and and measure the tip displacement of the IPMC sensor during travel using imaging and image process techniques, and compare to acquired voltage data from the sensor.&lt;/li&gt;
&lt;li&gt;Capture and display shed vortices from the experiment.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ionic-polymer-metal-composites-an-overview&#34;&gt;Ionic Polymer-Metal Composites: An Overview&lt;/h2&gt;
&lt;p&gt;IPMCs are unique electroactive polymers in that they exhibit both electromechanical (electrical to mechanical) and mechanoelectrical (mechanical to electrical) transduction, like that of piezoelectric materials, and are constructed from flexible polymers that can sustain large deformations and strains. The core structure of an IPMC is an ionomeric-polymer (ionomer), which consists of strong ionic groups attached to a charge-neutral polymer backbone. With this ionomer structure, the IPMC is formed by compositing an electrode material, typically a noble metal (such as platinum, gold, palladium, or silver), onto the surface of a thin ionomer membrane. This process forms the final material, a combined structure of an ionomer and metal electrodes, forming an ionic polymer-metal composite.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Ionic_polymer-metal_composites&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/IPMC_Actuation.jpg&#34; alt=&#34;IPMC&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.researchgate.net/figure/The-IPMC-material-under-electric-%5cstimulation_fig4_224318764&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/IPMC_Actuation2.jpg&#34; alt=&#34;IPMC&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The choice of backbone ionomer, electrode material, mobile ion species, solvent, and hydration level all have an immense impact on the behavior and performance of IPMC materials, demonstrating their highly complex nature.&lt;/p&gt;
&lt;p&gt;Regarding IPMCs as a sensor, induced deformation is believed to cause a redistribution of cations within the porous network due to mobility in the solvent, in addition to the anion-clusters deforming with the material such that the clusters form effective dipoles which induce a detectable signal along the electrodes, often within the millivolt range. The work presented herein will be focused on this aspect of IPMC physics.&lt;/p&gt;
&lt;h2 id=&#34;principles-of-flow-sensing&#34;&gt;Principles of Flow Sensing&lt;/h2&gt;
&lt;p&gt;One of the more prominent uses of IPMC sensors in underwater applications has been in the development of IPMC-based flow sensor devices. There have been two approaches in this endeavor, one of which involves interpreting the characteristic response directly, and the other requiring additional signal processing within the frequency domain.  The former is dependent relating the acquired voltage response directly to the environmental causes of displacement surrounding the IPMC. The figure below is a still-frame of an oscillating IPMC due to a shaker at 10 Hz.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/IPMC_Sensing.PNG&#34; alt=&#34;IPMC&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;experimental-setup&#34;&gt;Experimental Setup&lt;/h2&gt;
&lt;h3 id=&#34;equipment&#34;&gt;Equipment&lt;/h3&gt;
&lt;p&gt;Experiments were conducted within an 85 gal aquarium with the IPMC sensor mounted to an inverted linear belt slide system (MacronDynamics MSA-M6S) driven by an stepper motor (Applied Motion Products SSM23IP-4EG). The motor software was programmed to run at 200 rps, traveling at 150 mm/rev (300 mm/s). Voltage readings were acquired directly using a Keithley 6510 DAQ.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Setup.PNG&#34; alt=&#34;IPMC&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;camera-configuration&#34;&gt;Camera Configuration&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Config.jpg&#34; alt=&#34;IPMC&#34;&gt;
Three cameras were used for three individual applications: velocity, tip deflection, and particle tracking.&lt;/p&gt;
&lt;h5 id=&#34;camera-1-velocity-canon-eos-rebel-sl1&#34;&gt;Camera 1: Velocity (Canon EOS Rebel SL1)&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera1.jpg&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;p&gt;Fixed directly facing the side wall of the aquarium, camera 1 will be capturing the travel of the sensor mount. The camera is fitted with the stock 18-55mm Canon lens. Video was captured at 1080p, 30 fps. The far-side of the aquarium is fitted with a 1 inch grid poster that will be used when determining the calibration factor of the footage. Various light-sources were set behind the background image in order to produce a backlit, silhouette-esq footage of the sensor mount traveling.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera1_Setup.PNG&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;camera-2-tip-deflection-osmo-action&#34;&gt;Camera 2: Tip Deflection (OSMO Action)&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera2.jpg&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;p&gt;Camera 2 was mounted directly to the carriage to travel alongside the sensor, directly observing sensor deformation from an above view. Camera 2 will be used to  relate the dynamic tip displacement of the IPMC to the acquired voltage response. Camera 2 captured high speed footage at 1080p, 240 fps, ideally to capture the nuance in the deformation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera2_Setup.jpg&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;camera-3-particle-tracking-gopro-hero4-session&#34;&gt;Camera 3: Particle Tracking (GoPro Hero4 Session)&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera3.jpg&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;p&gt;Camera 3 was placed at a fixed location on the floor of the aquarium where it was used to capture the life cycle of the shed vortices from the carriage/bluff body. The camera was set to capture footage at 1080p, 30 fps. In addition, to better visualize the vortices, packing foam was shredding into pieces, ultimately functioning as tracking particles which assisted in image processing the flow trends on the surface of the water.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Camera3_Setup.PNG&#34; alt=&#34;Camera&#34;&gt;
&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/PIV.jpg&#34; alt=&#34;Camera&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;implementing-mathematica&#34;&gt;Implementing Mathematica&lt;/h2&gt;
&lt;h3 id=&#34;velocity-tracking&#34;&gt;Velocity Tracking&lt;/h3&gt;
&lt;p&gt;In this section, Mathematica was implemented to detect the velocity of a discrete binarized section of the sensor carriage mount. The found velocity can then be used in calculating the expected frequency of vortex shedding and can be used to verify the set velocity from the provided linear belt slide software. An assumption is made that the carriage, clamp, and IPMC sensor are traveling as a single body, and thus share the same velocity.  Prior to analysis, the captured experimental video was exported as a series of .png images through an external video editing software, which was then imported into Mathematica in the following cells. The images must be resized due to the large quantity. The spatial calibration factor was determined using the 1&amp;quot; grid background, which is highlighted in the first image shown.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Setting Directory and Accessing Images *)
SetDirectory[&amp;quot;dir&amp;quot;]; 
(* Change file directory to file containing images *)
images = FileNames[&amp;quot;*.png&amp;quot;];
count = 1;
Do[imagevar[count++] = Import[image], {image, images}];

(* Storing and Resizing Images *)
Table[imagevar[i], {i, 1, 60}];
sideimgs = Map[ImageResize[#, 500] &amp;amp;, %];

(* Using Background for Spatial Calibration - each square was 1&amp;quot;, 1 \
ft total *)
coords = {{215.`, 35.`}, {49.`, 34.`}};
HighlightImage[sideimgs[[1]], {coords[[1]], coords[[2]]}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Velocity1.jpg&#34; alt=&#34;Velocity&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Finding Calibration Factor and Labeling Important Variables*)
distperpixel = 304.8/EuclideanDistance[coords[[1]], coords[[2]]];
fps = 30;
dt = 1/fps;
tmax = Length[sideimgs]*dt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A mask was applied to isolate a specific region of capture that will be used for simplifying the binarization of the moving carriage. With the mask applied, the series of images were then color separated into CMYK color channels. The yellow channel, which best isolated the color of the clamp, was used to easily identify the moving carriage using a threshold binarization.  The ComponentMeasurements function was then applied to determine the centroid of the binarized component within each frame. The &amp;ldquo;centroids&amp;rdquo; variable was specifically used for velocity measurement, while &amp;ldquo;centroid&amp;rdquo; was used for highlighting the carriage in the tracking animation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Applying mask to focus on specific region *)
mask = &amp;quot;maskimg&amp;quot;;
binimgs = sideimgs*mask;

(* Color Separating and Binarizing Yellow Channel *)
binimgs = Map[ColorSeparate[#, &amp;quot;CMYK&amp;quot;][[3]] &amp;amp;, binimgs];
Map[DeleteSmallComponents[Binarize[#, 0.7]] &amp;amp;, binimgs];
centroid = Map[ComponentMeasurements[#, &amp;quot;Centroid&amp;quot;] &amp;amp;, %][[All, 1, 2]]; (* Centroid for Highlight Image *)
centroids = Map[ComponentMeasurements[#, &amp;quot;Centroid&amp;quot;] &amp;amp;, %%][[All, 1, 2, 1]]; (* Centroid for Velocity Component *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A list of velocities were then established by determining distance travel in successive frames and then by subsequently dividing the time step and and multiplying by the calibration factor. A &amp;ldquo;0&amp;rdquo; value was appended to the velocity list to account for the carriage exiting the FOV at the final frame. A mean velocity was then calculated by partitioning a stable region of velocities. The results were then plotted using ListLinePlot.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Velocity and Time *)
velo = Table[-distperpixel*(centroids[[i + 1]] - centroids[[i]])/
     dt, {i, 1, Length[centroids] - 1}];
time = Range[0, tmax, dt];
velo = Table[{time[[i]], velo[[i]]}, {i, 1, Length[velo]}];
velo = Append[velo, {59/30, 0}]; (* Adding 0 to end *)

(* Mean Velocity Line *)
peakvel = Table[{time[[i]], Mean[peakvelo]}, {i, 5, Length[velo] - 1}];

(* Plotting *) 
(* Velocity and Time *)
velo = Table[-distperpixel*(centroids[[i + 1]] - centroids[[i]])/
     dt, {i, 1, Length[centroids] - 1}];
time = Range[0, tmax, dt];
velo = Table[{time[[i]], velo[[i]]}, {i, 1, Length[velo]}];
velo = Append[velo, {59/30, 0}]; (* Adding 0 to end *)

(* Mean Velocity Line *)
peakvel = Table[{time[[i]], Mean[peakvelo]}, {i, 5, Length[velo] - 1}];

(* Plotting *) 
Show[{ListLinePlot[velo, PlotLegends -&amp;gt; {&amp;quot;Velocity&amp;quot;}], 
  ListLinePlot[peakvel, PlotStyle -&amp;gt; Orange, 
   PlotLegends -&amp;gt; {&amp;quot;Mean Velocity&amp;quot;}]}]
peakvelo = {-383.27456575836163`, -301.14430166728414`, \
-261.3235675625189`, -368.34179046907514`, -313.5882810750235`, \
-303.6330975488312`, -313.5882810750235`, -328.52105636430997`, \
-328.52105636430997`, -301.14430166728414`, -355.8978110613358`, \
-328.52105636430997`, -301.14430166728414`, -316.7881614941556`, \
-328.52105636430997`, -373.10605687089503`, -310.87825889289326`, \
-313.31174819929595`, -343.73036452932394`, -355.621278185609`, \
-301.42083454301087`, -328.52105636430997`, -301.57885332914157`, \
-340.2539512344643`, -343.73036452932394`, -340.6885028963218`, \
-328.52105636430997`, -355.8978110613358`, -328.52105636430997`, \
-328.52105636430997`, -312.09500354609384`, -328.52105636430997`, \
-432.55272421301`, -260.4702661174146`, -359.808776018056`, \
-332.43202132102704`, -328.52105636430997`, -328.52105636430997`, \
-328.52105636430997`, -328.52105636430997`, -328.52105636430997`, \
-328.52105636430997`, -355.8978110613358`, -328.52105636430997`, \
-328.52105636430997`, -301.14430166728414`, -355.8978110613358`, \
-328.52105636430997`, -328.52105636430997`, -328.52105636430997`, \
-328.52105636430997`, -328.52105636430997`, -328.52105636430997`, \
-410.65132045538746`, -355.8978110613358`};
Mean[peakvelo]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Velocity_Output.PNG&#34; alt=&#34;Velocity&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Animating Plot *)
animvelo = Table[velo[[1 ;; i]], {i, 1, Length[velo]}];
animpeakvel = Table[peakvel[[1 ;; i]], {i, 1, Length[peakvel]}];
Grid[{{&amp;quot;Tracking&amp;quot;, 
   &amp;quot;Velocity Plot&amp;quot;}, {ListAnimate[
    Table[HighlightImage[sideimgs[[i]], centroid[[i]]], {i, 1, 
      Length[sideimgs]}], 30], 
   ListAnimate[
    Table[ListLinePlot[animvelo[[i]], 
      PlotRange -&amp;gt; {{0, 2.2}, {-420, 0}}], {i, 1, Length[animvelo], 
      1}], 30]}}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/706547672aa0fd85478270addef67b0d.gif&#34; alt=&#34;Velocity&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ipmc-displacement-tracking&#34;&gt;IPMC Displacement Tracking&lt;/h3&gt;
&lt;p&gt;The following section of code is used to track IPMC deformation during travel. Similar to the first portion of code, images of gathered experimental footage were imported and resized for data management. Prior to binarization, a mask was applied to each frame to isolate the region of interest. Due to difficulty in binarization, a specific range of frames were chosen where the binarization was found to be the most stable. During binarization, a Sobel edge detection kernel was applied to increase accuracy of binarization by detecting the edge of the rectangular IPMC. A second mask was then applied to segment the IPMC into four sections for tracking curvature. There was difficulty in binarizing this set of footage due to the reflection of the water and almost near transparency of the IPMC. It may be useful to attempt to make the points of interest more prominent during experimental imaging for better clarity and accuracy during binarization. The ComponentMeasurement feature was then used to determine the centroids of each segmented section of the IPMC during travel.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Setting Directory *)
SetDirectory[
  &amp;quot;C:\\Users\\Nazanin\\Desktop\\Image Processing Project\\For \
Mathematica\\Tip Deflection\\&amp;quot;]; (* Change file directory to file \
containing images *)
images = FileNames[&amp;quot;*.png&amp;quot;];
count = 1;
Do[imagevar[count++] = Import[image], {image, images}];

(* Storing and Resizing *)
Table[imagevar[i], {i, 1, 1164}];
topimgs = Map[ImageResize[#, 500] &amp;amp;, %];

mask1 = &amp;quot;mask1.jpg&amp;quot;; (* The first mask is applied for simplifying the initial binarization \
*)
mask2 = &amp;quot;mask2.jpg&amp;quot;; (* The second mask is applied to create 4 separate components which \
we will be tracking *)

(* Binarizing *)
Components = 
  mask2*Table[
    Closing[DeleteSmallComponents[
      EdgeDetect[Binarize[mask1*topimgs[[i]], .2], 
       Method -&amp;gt; &amp;quot;Sobel&amp;quot;]], 7], {i, 190, 500, 11}];
ListAnimate[Components]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3116183b4dff47153193673f69fa87af.gif&#34; alt=&#34;Displacement&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Finding the centroids *)
centroids = 
  Table[ComponentMeasurements[Components[[i]], &amp;quot;Centroid&amp;quot;], {i, 1, 
    Length[Components]}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The centroids were then mapped onto the footage of the IPMC for visual confirmation. Spatial calibration was then conducted using the length of the IPMC, which was known to be 30 mm from clamp to tip.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Grabbing images of just the frames of footage used *)
mapimgs = Table[topimgs[[i]], {i, 190, 500, 11}];
ListAnimate[
 Table[HighlightImage[mapimgs[[i]], centroids[[i, All, 2]]], {i, 1, 
   Length[mapimgs]}]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/4f8145578ff82b43731f2e660a4db53f.gif&#34; alt=&#34;Displacement&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Spatial Calibration - IPMC from clamp to tip was 30 mm *)
coords = {{273.`, 134.`}, {251.`, 18.`}};
HighlightImage[topimgs[[1]], {coords[[1]], coords[[2]]}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Displacement.PNG&#34; alt=&#34;Displacement&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Finding Calibration Factor and Labeling Important Variables*)
distperpixel = 
  30/EuclideanDistance[coords[[1]], coords[[2]]]; (* mm/px *)
fps = 240;
dt = 1/fps; (* Actual time step *)
dt2 = 11/fps; (* Samping gap from binarization step *)
t0 = 190*dt;(* initial time - starting frame*)
tf = 500*dt ;(* final time - ending frame *)
time = Range[0, (tf - t0), dt2] // N; (* Time range was approx 1.3 seconds *)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Displacement was calculated by determining the distance traveled by the centroid of successive frames. The centroid of each component was then plotted which reveals the effects of curvature, as the furthest points from the clamp have the highest amplitude. This displacement plot was also compared to the voltage response acquired from the IPMC directly using a data acquisition device. These two plots show very similar trends.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Displacement between component centroids per frame *)
Displacement = 
  Table[distperpixel*(centroids[[i + 1, All, 2]] - 
      centroids[[i, All, 2]]), {i, 1, Length[centroids] - 1}];

(* Plot of All Centroid Displacement *)
ListLinePlot[{Displacement[[All, 1, 1]], Displacement[[All, 2, 1]], 
  Displacement[[All, 3, 1]], Displacement[[All, 4, 1]]}, 
 PlotLegends -&amp;gt; {&amp;quot;Point 1&amp;quot;, &amp;quot;Point 2&amp;quot;, &amp;quot;Point 3&amp;quot;, &amp;quot;Point 4&amp;quot;}, 
 PlotLabel -&amp;gt; &amp;quot;IPMC Displacement Tracking&amp;quot;, 
 AxesLabel -&amp;gt; {&amp;quot;Frame&amp;quot;, &amp;quot;Displacement (mm)&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Displacement2.PNG&#34; alt=&#34;Displacement&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Comparing to Voltage Response *)
s = Import[
   &amp;quot;C:\\Users\\Nazanin\\Desktop\\Image Processing Project\\11262019 \
Data\\Tip Deflection Data.xlsx&amp;quot;];
V = Table[{s[[1, i, 1]], (s[[1, i, 2]] - 0.00020)/0.00006}, {i, 1, 
    63}]; (* Normalizing Data *)
VoltagePlot = 
  ListLinePlot[V, PlotLabel -&amp;gt; &amp;quot;IPMC Voltage Response&amp;quot;, 
   AxesLabel -&amp;gt; {&amp;quot;Time (s)&amp;quot;, &amp;quot;Voltage&amp;quot;}, GridLines -&amp;gt; Automatic];

(* Attaching Relative Time to Max Displacement Data *)
X = Table[{time[[i]], Displacement[[i, 1, 1]]}, {i, 1, 
    Length[Displacement]}];
DisplacementPlot = 
  ListLinePlot[X, PlotLabel -&amp;gt; &amp;quot;IPMC Max Displacement&amp;quot;, 
   AxesLabel -&amp;gt; {&amp;quot;Time (s)&amp;quot;, &amp;quot;Displacement (mm)&amp;quot;}, 
   GridLines -&amp;gt; Automatic];
Grid[{{Show[VoltagePlot, ImageSize -&amp;gt; Medium], 
   Show[DisplacementPlot, ImageSize -&amp;gt; Medium]}}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Displacement3.PNG&#34; alt=&#34;Displacement&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;particle-tracking&#34;&gt;Particle Tracking&lt;/h3&gt;
&lt;p&gt;In this section, pseudo-PIV images were obtained to show flow patterns over time at a fixed location. Experimental images were imported and resized for data management. A local adaptive binarize was used in order to identify particles. The experiment setup created limitations in isolating particles during binarization and thus environmental objects are seen in binarized images. This will in turn affect the accuracy of flow pattern analysis. Having particles that are dissimilar to the environment can potentially allow for better tracking and flow pattern analysis.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Setting Location and Grabbing Files *)
SetDirectory[
  &amp;quot;C:\\Users\\Nazanin\\Desktop\\Image Processing Project\\For \
Mathematica\\Underwater\\&amp;quot;]; (* Change file directory to file \
containing images *)
images = FileNames[&amp;quot;*.png&amp;quot;];
count = 1;
Do[imagevar[count++] = Import[image], {image, images}];

(* Storing Files and Resizing *)
Table[imagevar[i], {i, 1, 129}];
pivimgs = Map[ImageResize[#, 500] &amp;amp;, %];

(* Binarization *)
pivframes = 
  Table[Erosion[Opening[LocalAdaptiveBinarize[pivimgs[[i]], 4], 1], 
    1], {i, 20, 65, 1}];
pivframes[[1]]
pivimgs[[20]]
Transpose[ImagePartition[#, 25] &amp;amp; /@ pivframes, {3, 1, 2}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Particle1.PNG&#34; alt=&#34;Particle&#34;&gt;&lt;/p&gt;
&lt;p&gt;An example of partitioning a frame to determine displacements of each section of a single image. An image correlate was used to determine these displacement vectors. Once these displacement vectors were found an animation was made of the binarized images with an overlay of the displacement vectors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;(* Example: Partitioning to 25 Boxes *)
GraphicsGrid[ImagePartition[pivframes[[1]], 25]] 
ColorNegate@
     ImageAdjust@
      Image[ImageCorrelate[#[[2]], #[[1]], 
        EuclideanDistance]] &amp;amp; /@ # &amp;amp; /@ %%(*calculate \
cross-correlations*)
ComponentMeasurements[Binarize[#, 0.9], &amp;quot;Centroid&amp;quot;][[1, 2]] - {32, 
       32} &amp;amp; /@ # &amp;amp; /@ %; (*get displacements*)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/ImageProcessing_Images/Particle2.PNG&#34; alt=&#34;Particle&#34;&gt;&lt;/p&gt;
&lt;p&gt;Final code below for determining the flow field. This code was found in Lecture 23 of ME 695.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Mathematica&#34;&gt;Module[{imgs = pivframes}, 
 Module[{divisions = 25, windowsize, windowcenters, disps, 
   imgdims = ImageDimensions[imgs[[1]]], selects},
  windowsize = imgdims/divisions;
  windowcenters = 
   Table[Table[{j*windowsize[[1]] - windowsize[[1]]/2, 
      i*windowsize[[2]] - windowsize[[2]]/2}, {j, divisions}], {i, 
     divisions}];
  disps = 
   ComponentMeasurements[
          Binarize[
           ColorNegate@
            ImageAdjust@
             ImageCorrelate[#[[2]], #[[1]], EuclideanDistance], 0.9], 
          &amp;quot;Centroid&amp;quot;][[1, 2]] - windowsize/2 &amp;amp; /@ # &amp;amp; /@ 
    Transpose[ImagePartition[#, windowsize] &amp;amp; /@ imgs, {3, 1, 2}];
  ListPlot[(selects = 
      Select[Flatten[Transpose[{windowcenters, disps}, {3, 1, 2, 4}], 
        1], Norm[#[[2]]] &amp;lt; 15 &amp;amp;])[[All, 2]], PlotRange -&amp;gt; All];
  
  ListAnimate[
   Show[ListStreamDensityPlot[{{#[[1, 1]], 
           imgdims[[2]] - #[[1, 2]]}, #[[2]]} &amp;amp; /@ selects, 
       ColorFunction -&amp;gt; &amp;quot;BlueGreenYellow&amp;quot;, StreamStyle -&amp;gt; Black, 
       PlotRange -&amp;gt; All], SetAlphaChannel[#, 0.25], Frame -&amp;gt; True, 
      ImageSize -&amp;gt; Large, PlotRange -&amp;gt; All] &amp;amp; /@ imgs, 2]
  ]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/e5256ceda0c05499c16082f50d56d8af.gif&#34; alt=&#34;Particle&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;future-work&#34;&gt;Future Work&lt;/h2&gt;
&lt;p&gt;Some improvements to the work presented herein include increasing the quality of imaging during the experimental process. This includes establishing a better lighting system, applying more prominent tracking points, and providing an in-plane measurement tool for more precise distance calibration. In the particle tracking experiment, providing a dark backdrop for better particle observation would allow for ease of image processing. Lastly, using the Hough transform function in Mathematica could improve on the IPMC deformation tracking.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design of Fuel Cell Powered UNLV Engineering Building</title>
      <link>https://nminaian.github.io/Website/project/sofc/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://nminaian.github.io/Website/project/sofc/</guid>
      <description>&lt;h2 id=&#34;work-in-progress&#34;&gt;Work in Progress&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>MEMS-based flow meter using an Ionic Polymer-Metal Composite Sensor</title>
      <link>https://nminaian.github.io/Website/project/mems/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://nminaian.github.io/Website/project/mems/</guid>
      <description>&lt;h2 id=&#34;design-concept&#34;&gt;Design Concept&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The proposed MEMS-based vortex flowmeter can be used in small- scale applications that necessitates devices with low power requirements.&lt;/li&gt;
&lt;li&gt;Ideally, the goal is to construct a small flow meter device (10 mm diameter) with the principle sensor being comprised of the electroactive polymer, an ionic polymer metal composite. IPMCs demonstrate sensing capabilities with heightened sensitivity.&lt;/li&gt;
&lt;li&gt;A successful attempt at this scale could demonstrate the feasibility of using this type of flow sensor in even smaller scale devices.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mechanism-of-typical-vortex-flow-meter&#34;&gt;Mechanism of Typical Vortex Flow Meter&lt;/h2&gt;
&lt;p&gt;A standard vortex flow meter operates based on the fluid phenomenon known as Karman Vortex Streets.
When flow is disrupted by an obstruction object or bluff body, vortices are shed from the object which is correlated to the following relationship known as the Strouhal number:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://latex.codecogs.com/svg.latex?St%20=%20fL/U&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;p&gt;where, ùëì is the frequency of vortex shedding, L is the characteristic length or hydraulic diameter of the object, and U is the flow velocity.&lt;/p&gt;
&lt;p&gt;This relationship can then be related to Reynolds number where under a large Reynolds number range, Strouhal number is approximately 0.20.&lt;/p&gt;
&lt;p&gt;A sensor can thus detect the frequency of the shed vortices, which is directly proportional to the flow velocity.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS1.png&#34; alt=&#34;MEMS&#34;&gt;
&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS2.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;p&gt;From Shanghai Yinuo Instrument Co. (Left) Cross section illustration of flow disruption in a pipe, generating vortices. (Right) Typical large vortex flow meter device.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS3.jpg&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;p&gt;Strouhal Number as a function of Reynolds Number. Image from Thermopedia&lt;/p&gt;
&lt;h2 id=&#34;advantages-and-disadvantages&#34;&gt;Advantages and Disadvantages&lt;/h2&gt;
&lt;h3 id=&#34;advantages&#34;&gt;Advantages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Silent in use&lt;/li&gt;
&lt;li&gt;No moving parts
&lt;ul&gt;
&lt;li&gt;Less degradation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Flexible usage range
&lt;ul&gt;
&lt;li&gt;100 &amp;lt; Re &amp;lt; 200,000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Low Power Requirements&lt;/li&gt;
&lt;li&gt;IPMC sensitivity can sense mild displacements that will occur from shed vortices&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;disadvantages&#34;&gt;Disadvantages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Requires analysis within the frequency domain to acquire velocity&lt;/li&gt;
&lt;li&gt;Flow must be continuous for measurement (no pulsating flow)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;concept-and-prototype-design&#34;&gt;Concept and Prototype Design&lt;/h2&gt;
&lt;h3 id=&#34;initial-version&#34;&gt;Initial Version&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS4.png&#34; alt=&#34;MEMS&#34;&gt;
&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS5.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;subsequent-and-final-version&#34;&gt;Subsequent and Final Version&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS6.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;p&gt;Failed and Completed Prints&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS7.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;physics-model---visualization-and-anticipation-of-vortex-shedding&#34;&gt;Physics Model - Visualization and Anticipation of Vortex Shedding&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A physics-based model was developed in COMSOL Multiphysics.&lt;/li&gt;
&lt;li&gt;Laminar flow physics was applied to a geometry resembling the cross-sectional area of the flowmeter device.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/0e91a2d53774171989e874033694cc85.gif&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;p&gt;Water at room temperature was set as the material and the normal inflow velocity was set to 0.07 m/s after an initialization step which was implemented to help the model run&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://latex.codecogs.com/svg.latex?%5Crho_w%20=%20997%20%5Bkg/m%5E3%5D&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://latex.codecogs.com/svg.latex?%5Cmu%20=%208.90%20%5Ctimes%2010%5E-4%20%5BPa-s%5D&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/Step.svg&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using the Reynolds number equation, this puts us at a Reynolds number of about 235.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/bf9f913d2066575e498155969682bd62.gif&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;experimental-setup&#34;&gt;Experimental Setup&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/a41b37e0e7597b4f8e675c9631e64772.gif&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A contact piece was designed and soldered to read the IPMC signal.&lt;/li&gt;
&lt;li&gt;A Masterflex L/S series peristaltic pump was used to control the flow rate of the flowmeter.
&lt;ul&gt;
&lt;li&gt;The flow rate was calibrated to the specific hosing used.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://latex.codecogs.com/svg.latex?Q_e=5900%20%5Bmm%5E3/s%5D&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://latex.codecogs.com/svg.latex?V_e=0.075%20%5Bm/s%5D&#34; alt=&#34;Equation&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Which results in a Reynolds number of 252, and thus an expected vortex shedding frequency of 4.76&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS8.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS9.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We can see the IPMC sensing the flow of the peristaltic pump in the following voltage reading plot.&lt;/li&gt;
&lt;li&gt;An FFT was performed on 2 of the 3 runs.&lt;/li&gt;
&lt;li&gt;Interestingly enough, we observe a noticeable frequency peak at around 4.7-5.0 Hz.&lt;/li&gt;
&lt;li&gt;However, it is important to note, this coincidentally is also the peristaltic pump pulse frequency as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://nminaian.github.io/Website/media/MEMS_Images/MEMS10.png&#34; alt=&#34;MEMS&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusionfuture-work&#34;&gt;Conclusion/Future Work&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;More experiments will have to be performed to validate the concept of the this design.&lt;/li&gt;
&lt;li&gt;Possible improvements:
&lt;ul&gt;
&lt;li&gt;A pulse dampener can be implemented into the setup&lt;/li&gt;
&lt;li&gt;Redesigning the flowmeter
&lt;ul&gt;
&lt;li&gt;Better access to main chamber&lt;/li&gt;
&lt;li&gt;Less clunky contact design&lt;/li&gt;
&lt;li&gt;Further miniaturization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Laminar Flow Faucet-less Smart Sink</title>
      <link>https://nminaian.github.io/Website/project/sink/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://nminaian.github.io/Website/project/sink/</guid>
      <description>&lt;h2 id=&#34;work-in-progress&#34;&gt;Work in Progress&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;&#39;https://nminaian.github.io/Website/media/Sink_Images/Lifsink_Poster.png&#39;&#34; alt=&#34;Sink&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
